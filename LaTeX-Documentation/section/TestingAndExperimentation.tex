\section{Testing and Experimentation}\label{sec:testing-and-experimentation}

\subsection{Testing and Experiment Scope}\label{subsec:testing-and-experiment-scope}

With respect to the hardware, there were different approaches
to testing and experimentation
at different stages of development.
The following provides an overview of the different objectives that were present during each stage of development:

\begin{itemize}
    \item \textbf{Ideation}:
    \begin{itemize}
        \item Maximize performance to power ratio
        \item Create a short list of configurations to further test
        during the assembly process
    \end{itemize}
    \item \textbf{Assembly}:
    \begin{itemize}
        \item Make use of the breadboard to physically explore configurations
        \item Settle on one configuration after testing has been
        accomplished for the shortlisted configurations
    \end{itemize}
    \item \textbf{Prototyping}:
    \begin{itemize}
        \item Solder parts and check continuity after soldering
        \item Explore soldering parts together to make servicing easier
        by reducing the number of connections between components.
        \item Make light considerations of accessibility/repairability when soldering parts together
    \end{itemize}
    \item \textbf{Finalizing}:
    \begin{itemize}
        \item Solder parts in a manner that conserves space for the hardware enclosure
        \item Make compromise between spatial compression and ease of repair
    \end{itemize}
\end{itemize}

As far as the software, a systematic approach was taken to ensure the
robustness and efficiency of the application.
The following objectives guided the testing and experimentation at various stages of development:

\begin{itemize}
    \item \textbf{Research}:
    \begin{itemize}
        \item Conduct Market Research
        \item Identify key challenges to state-of-the-art
        \item Conduct contemporary literature review
    \end{itemize}
    \item \textbf{Ideation}:
    \begin{itemize}
        \item Brainstorm a variety of potential solutions
        \item Shortlist a few of the aforementioned solutions
        \item Create possible architectures for front and back ends of application
        \item Create low-fidelity proof-of-concept
    \end{itemize}
    \item \textbf{Implementation}:
    \begin{itemize}
        \item Choose one configuration of tools and technologies
        \item Create high-fidelity prototype by implementing certain
        features in an agile fashion
        \item Leverage developers to test for function first,
        then optimization second
    \end{itemize}
    \item \textbf{Benchmarking}:
    \begin{itemize}
        \item Emphasize optimization of the code and robustness
        \item Achieve a code coverage of at least 80 percent
        \item Reduce test case excapes to zero
    \end{itemize}
    \item \textbf{Finalizing}:
    \begin{itemize}
        \item Make cosmetic changes to the application
        \item Create script for live demonstration rehearsal
        \item Repeatedly test the system to ensure stability and consistency over time.
    \end{itemize}
\end{itemize}

\subsection{Testing and Experiment Approach}\label{subsec:testing-and-experiment-approach}

% Hardware

Testing the hardware was an iterative process that entailed using simulations, continuity
checks, and constant soldering of different parts in different ways to conserve space to
make the hardware as physically unobtrusive as possible while keeping it easy to repair.
During the ideation phase, simulations were used with the Fritzing software where
different power deliveries and wiring configurations were tested via virtual
simulations.
This led to some of the compromises made as described in \textbf{Design Constraints, Problems, Trade-offs, and Solutions.}

During the assembly phase, a breadboard was used to test without spending time and
effort soldering and desoldering the configuration.
Once the hardware configuration reached a satisfactory level of performance, only then were the parts soldered
together.
During the prototyping phase, different wires and connectors were used to determine the best manner of mounting different components to one continuous
connection.
A proof of concept was made that had no consideration for conservation of space, and continuity checks were done with a multimeter to ensure that each
solder connection was made properly.

In finalizing the hardware configuration, several spare parts were soldered together
and connected onto the board that used different techniques to conserve space.
Again, the solder joints were tested for continuity with a multimeter.
In addition to conserving space, an additional consideration was made to avoid short-circuits
by exploring both electrical tape and heatshrink.
From there, ease of repair was taken into account by documenting the nature of the solder joints so end users
could easily replicate the consolidation done by the hardware system integrators.

% Software

In testing the software implementation, the primary goal was to validate the functionality,
reliability, and performance of the system across various components and integrations. %
The testing process was comprehensive, covering both unit and integration levels to
ensure the smooth functioning of individual elements as well as their
seamless integration into the whole system. %

The unit testing phase involved meticulously testing each system component in isolation,
scrutinizing the functions and methods within the Python and Flask backend, along
with the ReactJS frontend. %
The developers conducted a thorough examination of the functionality of MySQL database interactions and confirmed the dependable data
transmission between the microcontroller and the backend server using MicroPython. %

Integration testing was then conducted to secure a seamless connection between
the frontend, backend, and database, which guaranteed a consistent and accurate
flow of data. %
Validation was done by examining the communication efficiency between the microcontroller, sensors, and backend server, ensuring that the entire system
operated seamlessly when all components were brought together. %

\subsection{Testing and Experiment Results and Analysis}\label{subsec:testing-and-experiment-results-and-analysis}

While the majority of test cases passed successfully, demonstrating the system’s
robustness and reliability, any failed tests were promptly addressed,
with bugs fixed and tests rerun until success was achieved. %

\begin{itemize}
    \item \textbf{Performance Test Result Analysis}: The system performed well
    under normal conditions and was able to handle load up to performance benchmarks. %
    \item \textbf{Test Coverage}: To ensure confidence in the system’s reliability,
    tests achieved high coverage across the codebase. %
    \item \textbf{Bug Distribution Report}: Bugs were categorized based on their
    severity, with critical and major bugs given priority in fixing.  %
    GitHub Issues detailing of bugs, their severity, and the components
    they affected was created. %
\end{itemize}

\img{Jest-Test-Suite}{Using Jest Test Suite}
\img{JMeter_100reqBenchmark}{JMeter 100 Request Benchmark Metrics}
\img{GitHubIssues}{Issue Tracking System}

By rigorously following this comprehensive testing and experiment
approach, the developers ensured that the system was reliable,
performed well, and met all the defined requirements and benchmarks. %
